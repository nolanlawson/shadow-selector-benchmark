/**
 * Superclass for all implemented generators.
 */
class PRNG {
  /**
   * @constructor
   * @param {number | bigint} max -> Max number that can be generated by this generator.
   * @param {number | bigint} seed -> Initial seed.
   */
  constructor(max, seed) {
    /**
     * @protected
     * @readonly
     * @type {number | bigint}
     */
    this.max = max;
    /**
     * @protected
     * @type {number | bigint}
     */
    this._seed = seed;
  }

  /**
   * Casts the given BigInt number to an unsigned big int with the given
   * number of bits.
   *
   * @protected
   * @param {bigint} number -> A string param.
   * @param {number} bits -> An optional param (Closure syntax)
   * @return {bigint} This is the result
   */
  cast(number, bits) {
    return BigInt.asUintN(bits, number);
  }

  /**
   * Checks that a given number is within the range.
   *
   * @protected
   * @param {number} number -> A string param.
   * @throws Error -> Number greater than max.
   */
  checkNum(number) {
    if (number > this.max) {
      throw new Error(`Number greater than ${this.max}`);
    }
  }

  /**
   * Resets the PRNG.
   * To be implemented by sub-classes.
   *
   * @public
   * @throws Error -> Method not implemented.
   */
  reset() {
    if (this.constructor === PRNG) {
      throw new Error('Method not implemented');
    }
  }

  /**
   * Private method for integer generation.
   * To be implemented by sub-classes.
   *
   * @protected
   * @return {bigint} Random integer.
   */
  _int() {
    if (this.constructor === PRNG) {
      throw new Error('Method not implemented');
    }
    return BigInt(0);
  }

  /**
   * Generates a boolean with the formula random.float() >= 0.5
   *
   * @example
   * random.bool();
   *
   * @example
   * random.bool(); // true
   *
   * @public
   * @returns {boolean} True/False.
   */
  bool() {
    return this.float() >= 0.5;
  }

  /**
   * Generates a random boolean with probability of it being true denoted by the pTrue parameter.
   * For example, when pTrue=0.8, 80% of the numbers generated with this method will be true.
   *
   * @example
   * random.coin(pTrue);
   *
   * @example
   * random.coin(0.8); // true
   *
   * @public
   * @param {number} pTrue -> Probability of generating a true value.
   * @returns {boolean} True/False.
   */
  coin(pTrue = 0.5) {
    return this.float() < pTrue;
  }

  /**
   * Generates and returns the next number in the PRNGs sequence.
   *
   * @example
   * random.int();
   *
   * @example
   * random.int(); // 85424123
   *
   * @public
   * @returns {number} Number less than 2 ** 32 for 32 bit generators.
   */
  int() {
    return Number(this._int());
  }

  /**
   * Generates and returns the next number in the PRNGs sequence and returns it as a Bigint.
   *
   * @example
   * random.bigInt();
   *
   * @example
   * random.bigInt(); // 85424123n
   *
   * @public
   * @returns {bigint} Number less than 2 ** 32 for 32 bit generators represented as a BigInt class.
   */
  bigInt() {
    return this._int();
  }

  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float();
   *
   * @example
   * random.float(); // 0.234242
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float() {
    return this.int() * (1.0 / this.max);
  }

  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float53();
   *
   * @example
   * random.float53(); // 0.2342422341231
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float53() {
    const a = this.int() >>> 5;
    const b = this.int() >>> 6;

    return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
  }

  /**
   * Generates a number within the given range.
   *
   * @example
   * random.randRange(min, max);
   *
   * @example
   * const lowerBound = 4;
   * const upperBound = 2432;
   * random.randRange(lowerBound, upperBound); // 36.
   *
   * @public
   * @param {number} min -> Lower bound of the numbers to generate (inclusive).
   * @param {number} max -> Upper bound of the numbers to generate (inclusive).
   * @returns {number} Number min <= Number <= max.
   */
  randRange(min, max) {
    // Debiased Modulo method,
    // https://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt%28int%29
    // https://peteroupc.github.io/randomnotes.html
    // https://www.pcg-random.org/posts/bounded-rands.html
    const range = max - min;
    const t = this.max % range;
    let r = this.int();

    while (r < t) {
      r = this.int();
    }

    return min + (r % range);
  }

  /**
   * Generates a number below the given maximum.
   *
   * @example
   * random.randBelow(max);
   *
   * @example
   * const upperBound = 2432;
   * random.randBelow(upperBound);  // 285.
   *
   * @public
   * @param {number} max -> Upper bound of the numbers to generate (inclusive).
   * @returns {number} Number <= max
   */
  randBelow(max) {
    return this.randRange(0, max);
  }

  /**
   * Picks a random element from the array.
   *
   * @example
   * random.choice(array)
   *
   * @example
   * const arr = [1, 4, 2, 3];
   * random.choice(arr); // 4
   *
   * @public
   * @param {any[]} array -> Array of any type from which we randomly select one item.
   * @returns {any} A single item from the array of type ?.
   */
  choice(array) {
    return array[this.randBelow(array.length)];
  }

  /**
   * Randomly shuffles the given array using the fisher-yates algorithm.
   *
   * @example
   * random.shuffle(array, inPlace = false)
   *
   * @example
   * const arr = [1, 4, 2, 3];
   * const shuffled = random.shuffle(arr, false);
   * console.log(arr); // [1, 4, 2, 3]
   * console.log(shuffled); // [4, 2, 3, 1]
   *
   * @example
   * const arr = [1, 4, 2, 3];
   * const shuffled = random.shuffle(arr, true);
   * console.log(arr); // [4, 2, 3, 1]
   * console.log(shuffled); // [4, 2, 3, 1]
   *
   * @public
   * @param {any[]} array -> Array of any type to be shuffled.
   * @param {boolean} inPlace -> Shuffle the array (true) or shuffle a copy of array (false).
   * @returns {any[]} Array shuffled (inPlace === false), shuffled copy of array (inPlace === true).
   */
  shuffle(array, inPlace = true) {
    let toSort = array;

    if (!inPlace) {
      toSort = Array.from(toSort);
    }

    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle.
    for (let i = toSort.length - 1; i > 0; i--) {
      const j = this.randRange(0, i);
      const temp = toSort[i];
      toSort[i] = toSort[j];
      toSort[j] = temp;
    }

    return toSort;
  }

  /**
   * Creates an array of the given size populated with the result of the mapFn.
   *
   * @protected
   * @param {number} size -> Length of the array to create.
   * @param {function(): boolean | number | bigint} mapFn -> Function which we use to fill array.
   * @returns {boolean[] | number[] | bigint[]} Array created by repeated calls to the mapFn.
   */
  initArray(size, mapFn) {
    return Array.from({ length: size }, mapFn);
  }

  /**
   * Generates an n size array populated with booleans.
   *
   * @example
   * random.boolArray(size);
   *
   * @example
   * const size = 256;
   * random.boolArray(size);
   *
   * @public
   * @param {number} size -> Size of the array to generate.
   * @returns {boolean[]} Array[Boolean] of length size.
   */
  boolArray(size) {
    return this.initArray(size, () => this.bool());
  }

  /**
   * Generates an n size array of random booleans with probability of it being true
   * denoted by the pTrue parameter. For example, when pTrue=0.8, 80% of the numbers
   * in the generated array will be true.
   *
   * @example
   * random.coinArray(size, pTrue);
   *
   * @example
   * const size = 256;
   * const pTrue = 0.8;
   * random.coinArray(size, pTrue);
   *
   * @public
   * @param {number} size -> Size of the array to generate.
   * @param {number} pTrue -> Probability of generating a true value.
   * @returns {boolean[]} Array[Boolean] of length size.
   */
  coinArray(size, pTrue = 0.5) {
    return this.initArray(size, () => this.coin(pTrue));
  }

  /**
   * Generates an n size array populated with integers.
   *
   * @example
   * random.intArray(size);
   *
   * @example
   * const size = 256;
   * random.intArray(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {number[]} Array[Number] of length size.
   */
  intArray(size) {
    return this.initArray(size, () => this.int());
  }

  /**
   * Generates an n size array populated with Big Integers.
   *
   * @example
   * random.bigIntArray(size);
   *
   * @example
   * const size = 256;
   * random.bigIntArray(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {bigint[]} Array[BigInt] of length size.
   */
  bigIntArray(size) {
    return this.initArray(size, () => this.bigInt());
  }

  /**
   * Generates an n size array populated within the given range.
   *
   * @example
   * random.randRangeArray(size, min, max);
   *
   * @example
   * const size = 256;
   * const lowerBound = 4;
   * const upperBound = 2432;
   * random.randRangeArray(size, lowerBound, upperBound);
   *
   * @public
   * @param {number} size -> Size of the array to generate.
   * @param {number} min -> Lower bound of the numbers to generate (inclusive).
   * @param {number} max -> Upper bound of the numbers to generate (inclusive).
   * @returns {number[]} Array[Number] of length size filled w/ min <= num <= max.
   */
  randRangeArray(size, min, max) {
    return this.initArray(size, () => this.randRange(min, max));
  }

  /**
   * Generates an n size array populated with floats.
   *
   * @example
   * random.floatArray(size);
   *
   * @example
   * const size = 256;
   * random.floatArray(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {number[]} Array[Number] between 0.0 - 1.0 of length size.
   */
  floatArray(size) {
    return this.initArray(size, () => this.float());
  }

  /**
   * Generates an n size array populated with floats.
   *
   * @example
   * random.float53Array(size);
   *
   * @example
   * const size = 256;
   * random.float53Array(size);
   *
   * @public
   * @param size -> Size of the array to generate.
   * @returns {number[]} Array[Number] between 0.0 - 1.0 of length size.
   */
  float53Array(size) {
    return this.initArray(size, () => this.float53());
  }
}

/**
 * 64 bit modification of PRNG class.
 * @class
 * @extends {PRNG}
 * @param {number | bigint} max -> Max number that can be generated by this generator.
 * @param {number | bigint} seed -> Initial seed.
 */
class PRNG64 extends PRNG {
  /**
   * @constructor
   * @param {number | bigint} max -> Max number that can be generated by this generator.
   * @param {number | bigint} seed -> Initial seed.
   */
  constructor(max, seed) {
    super(max, seed);
  }

  /**
   * Generates and returns the next number in the PRNGs sequence.
   * As this is a 64 bit generator and javascript integers are limited to 53 bits,
   * the generated BigInt result is right-shifted 11 bits; discarding the least significant bits.
   *
   * @example
   * random.int();
   *
   * @example
   * random.int(); // 85424123
   *
   * @public
   * @returns {number} Number less than 2 ** 53 for 64 bit generators.
   */
  int() {
    // Javascript only has 2 ** 53 integer positions, take 64 bit output and only take the upper 53 bits for use
    // as our output Number in int mode.
    return Number(this._int() >> 11n);
  }

  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float();
   *
   * @example
   * random.float(); // 0.234242
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float() {
    return this.int() / this.max;
  }

  /**
   * Generates a random floating point number.
   *
   * @example
   * random.float53();
   *
   * @example
   * random.float53(); // 0.2342422341231
   *
   * @public
   * @returns {number} Float between 0.0 - 1.0.
   */
  float53() {
    return this.float();
  }
}

/** @type {number} */
/** @type {number} */
const MAX53 = 2 ** 53;

/**
 * XorShift generators are fast, efficient generators with good randomness quality.
 * This implementation has 64 bit output with 64 bits of internal state.
 *
 * @example
 * const random = new XORShift64(11234, 13, 7, 17);
 *
 * @class
 * @extends {PRNG64}
 * @param {number | bigint} seed -> Initial seed.
 * @param {number | bigint} a -> First bit shift parameter.
 * @param {number | bigint} b -> Second bit shift parameter.
 * @param {number | bigint} c -> Third bit shift parameter.
 */
class XORShift64 extends PRNG64 {
  /**
   * @constructor
   * @param {number | bigint} seed -> Initial seed.
   * @param {number | bigint} a -> First bit shift parameter.
   * @param {number | bigint} b -> Second bit shift parameter.
   * @param {number | bigint} c -> Third bit shift parameter.
   */
  constructor(seed = Date.now(), a = 13, b = 7, c = 17) {
    super(MAX53, BigInt(seed));
    this.seed = seed;
    /**
     * @private
     * @type {BigInt}
     */
    this.a = this.cast(BigInt(a), 64);
    /**
     * @private
     * @type {BigInt}
     */
    this.b = this.cast(BigInt(b), 64);
    /**
     * @private
     * @type {BigInt}
     */
    this.c = this.cast(BigInt(c), 64);
  }

  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
  }

  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }

  /**
   * Converts seed into BigInt + takes steps to reset generator.
   *
   * @public
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = this.cast(BigInt(seed), 64);
    this.x = this._seed;
  }

  _int() {
    let { x } = this;
    x ^= x << this.a;
    x = this.cast(x, 64);
    x ^= x >> this.b;
    x ^= x << this.c;
    x = this.cast(x, 64);
    this.x = x;
    return x;
  }
}

/**
 * Linear Congruential Generator (LCG) is a simple generator originally devised in 1951,
 * if you need something quick with minimal memory usage and not the best quality randomness,
 * this is for you. 32 bits of output.
 *
 * @example
 * const random = new LCG(1234, 1664525, 1013904223, 4294967296);
 *
 * @class
 * @extends {PRNG}
 * @param {number} seed ->  Initial seed.
 * @param {number} a -> Multiplier parameter.
 * @param {number} c -> Increment parameter.
 * @param {number} m -> Modulus parameter.
 */
class LCG extends PRNG {
  /**
   * @constructor
   * @param {number} seed ->  Initial seed.
   * @param {number} a -> Multiplier parameter.
   * @param {number} c -> Increment parameter.
   * @param {number} m -> Modulus parameter.
   */
  constructor(seed = Date.now(), a = 1664525, c = 1013904223, m = 4294967296) {
    super(m, seed);
    [seed, a, c, m].forEach((num) => this.checkNum(num));
    this.seed = seed;
    Object.assign(this, { a, c, m }); // Group assignment for brevity.
  }

  /**
   * Resets the generator to its original state.
   */
  reset() {
    this.x = this.seed;
  }

  /**
   * Seed getter.
   *
   * @public
   * @returns {number | bigint} Retrieves seed.
   */
  get seed() {
    return this._seed;
  }

  /**
   * Converts seed into BigInt + takes steps to reset generator.
   * @param {number | bigint} seed -> New seed to set.
   */
  set seed(seed) {
    this._seed = seed;
    this.x = this._seed;
  }

  _int() {
    this.x = (this.a * this.x + this.c) % this.m;
    return BigInt(this.x);
  }
}

new XORShift64(Date.now());
new XORShift64(Date.now());

const SEED = 114569486; // use a consistent seed

let random;

const tags = [
  'custom-a',
  'custom-b',
  'custom-c',
  'custom-d',
  'custom-e',
  'custom-f',
  'custom-g',
  'custom-h',
  'custom-i',
  'custom-j',
];

const colors = [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "goldenrod",
  "gold",
  "gray",
  "green",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavenderblush",
  "lavender",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
];

const randomString = () => 'x' + Math.round(random.int()).toString(16);

let attributes;

function randomChoice(arr) {
  return random.choice(arr)
}

const randomTag = () => randomChoice(tags);
const randomColor = () => randomChoice(colors);

const randomNumber = (from, to) => random.randRange(from, to);
const randomBool = () => random.bool();
const randomCoin = (prob) => random.coin(prob);
const randomAttribute = () => {
  // attributes are likely to collide (e.g. aria-label, aria-pressed), so used a global fixed set
  if (!attributes) {
    attributes = Array(100).fill().map(() => `data-${randomString()}`);
  }
  return randomChoice(attributes)
};

const resetRandomSeed = () => {
  attributes = undefined; // reset
  random = new LCG(SEED); // LCG used because it's relatively fast compared to others
};

resetRandomSeed();

var messageIds = 0;

function onMessage (self, e) {
  var message = e.data;
  if (!Array.isArray(message) || message.length < 2) {
    // Ignore - this message is not for us.
    return
  }
  var messageId = message[0];
  var error = message[1];
  var result = message[2];

  var callback = self._callbacks[messageId];

  if (!callback) {
    // Ignore - user might have created multiple PromiseWorkers.
    // This message is not for us.
    return
  }

  delete self._callbacks[messageId];
  callback(error, result);
}

function PromiseWorker (worker) {
  var self = this;
  self._worker = worker;
  self._callbacks = {};

  worker.addEventListener('message', function (e) {
    onMessage(self, e);
  });
}

PromiseWorker.prototype.postMessage = function (userMessage) {
  var self = this;
  var messageId = messageIds++;

  var messageToSend = [messageId, userMessage];

  return new Promise(function (resolve, reject) {
    self._callbacks[messageId] = function (error, result) {
      if (error) {
        return reject(new Error(error.message))
      }
      resolve(result);
    };

    /* istanbul ignore if */
    if (typeof self._worker.controller !== 'undefined') {
      // service worker, use MessageChannels because e.source is broken in Chrome < 51:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=543198
      var channel = new MessageChannel();
      channel.port1.onmessage = function (e) {
        onMessage(self, e);
      };
      self._worker.controller.postMessage(messageToSend, [channel.port2]);
    } else {
      // web worker
      self._worker.postMessage(messageToSend);
    }
  })
};

var promiseWorker = PromiseWorker;

const poolSize = (navigator.hardwareConcurrency ?? 2) - 1;

let currentWorker = 0;
const workerUrl = new URL('./worker.js', import.meta.url);
const workerPool = new Array(poolSize).fill().map(() => new promiseWorker(new Worker(workerUrl.toString())));

function nextWorker() {
  try {
    return workerPool[currentWorker]
  } finally {
    currentWorker++;
    if (currentWorker === poolSize) {
      currentWorker = 0;
    }
  }
}

async function scopeStyle({ css, token, useClasses, mode, componentTag }) {
  const res = await nextWorker().postMessage({ css, token, useClasses, mode, componentTag });
  return res
}

const $ = document.querySelector.bind(document);
const $$ = _ => [...document.querySelectorAll(_)];

const goButton = $('#go');
const useShadowDomInput = $('#useShadowDom');
const scopeStylesInput = $('#scopeStyles');
const numRulesInput = $('#numRules');
const numComponentsInput = $('#numComponents');
const numElementsInput = $('#numElements');
const numClassesInput = $('#numClasses');
const numAttributesInput = $('#numAttributes');
const oneBigStyleInput = $('#oneBigStyle');
const useClassesInput = $('#useClasses');
const scopeModeInputLast = $('#scopeModeLast');
const scopeModeInputEvery = $('#scopeModeEvery');
const scopeModeInputPrefix = $('#scopeModePrefix');
const container = $('#container');
const display = $('#display');

let scopeId = 0;
let componentTagNameIndex = 0;

scopeStylesInput.addEventListener('change', () => {
  for (const input of [useClassesInput, scopeModeInputLast, scopeModeInputEvery, scopeModeInputPrefix]) {
    input.disabled = !scopeStylesInput.checked;
  }
});

goButton.addEventListener('click', e => {
  e.preventDefault();
  runTest();
});

async function runTest() {
  goButton.disabled = true;
  try {
    await doRunTest();
  } finally {
    goButton.disabled = false;
  }
}

function generateAttributeValueSelector({ name, value }) {
  return `[${name}=${JSON.stringify(value)}]`
}

function generateRandomCssRule({ classes, attributes, tags }) {

  const allSelectorTypes = ['tag', 'class', 'attributeName', 'attributeValue', 'notClass', 'notAttribute', 'nthChild'];

  function generateRandomFullSelector() {
    let str = '';
    do {
      const firstSelectorType = randomChoice(allSelectorTypes);
      str += generateRandomSelector(firstSelectorType);

      if (randomBool()) {
        // concatenating a tag to something else is not okay
        const secondSelectorType = randomChoice(allSelectorTypes.filter(_ => _ !== 'tag'));
        str += generateRandomSelector(secondSelectorType); // combinator selector
      }
      str += ' '; // descendant selector
    } while (randomBool())

    return str
  }

  function generateRandomSelector(selectorType) {
    switch (selectorType) {
      case 'tag':
        return tags.length ? randomChoice(tags) : randomString()
      case 'class':
        return '.' + (classes.length ? randomChoice(classes) : randomString())
      case 'attributeName':
        return '[' + (attributes.length ? randomChoice(attributes.map(_ => _.name)) : randomString()) + ']'
      case 'attributeValue':
        return generateAttributeValueSelector(attributes.length ? randomChoice(attributes) : { name: randomString(), value: randomString() })
      case 'notClass':
        return ':not(.' + (classes.length ? randomChoice(classes) : randomString()) + ')'
      case 'notAttribute':
        return ':not([' + (attributes.length ? randomChoice(attributes.map(_ => _.name)) : randomString()) + '])'
      case 'nthChild':
        return `:nth-child(${randomNumber(1, 5)})`
    }
  }

  const selector = generateRandomFullSelector();

  return `${selector} { background-color: ${randomColor()}; }`
}

function generateRandomCss({ numRules, classes, attributes, tags }) {
  let str = '';

  for (let i = 0; i < numRules; i++) {
    str += generateRandomCssRule({ classes, attributes, tags }) + '\n\n';
  }

  return str
}

function createStyleTag(css) {
  const style = document.createElement('style');
  style.textContent = css;
  return style
}

function injectGlobalCss(css) {
  document.head.appendChild(createStyleTag(css));
}

function reset() {
  container.innerHTML = '';
  $$('style').forEach(style => style.remove());
  resetRandomSeed();
  scopeId = 0;
  componentTagNameIndex = 0;
}

async function doRunTest() {
  const numComponents = parseInt(numComponentsInput.value, 10);
  const numElementsPerComponent = parseInt(numElementsInput.value, 10);
  const numClassesPerElement = parseInt(numClassesInput.value, 10);
  const numAttributesPerElement = parseInt(numAttributesInput.value, 10);
  const numRulesPerComponent = parseInt(numRulesInput.value, 10);
  const useShadowDom = useShadowDomInput.checked;
  const scopeStyles = scopeStylesInput.checked;
  const oneBigStyle = oneBigStyleInput.checked;
  const useClasses = useClassesInput.checked;
  const scopeMode = scopeModeInputLast.checked ? 'last' : scopeModeInputEvery.checked ? 'every' : 'prefix';

  reset();

  async function generateRandomScopedCss({ classes, attributes, tags, scopeToken, useClasses, scopeMode, componentTag }) {
    const css = generateRandomCss({ numRules: numRulesPerComponent, classes, attributes, tags });
    if (!scopeStyles) {
      return css
    }
    return (await scopeStyle({ css, token: scopeToken, useClasses, mode: scopeMode, componentTag }))
  }

  function createComponent({ scopeToken }) {
    const component = document.createElement(`my-component-${componentTagNameIndex++}`);

    let renderRoot = component;
    if (useShadowDom) {
      const shadow = renderRoot.attachShadow({ mode: 'open' });
      renderRoot = shadow;
    }

    let lastElm;

    const tags = [];
    const classes = [];
    const attributes = [];

    for (let i = 0; i < numElementsPerComponent; i++) {
      const tag = randomTag();
      tags.push(tag);
      const elm = document.createElement(tag);
      Object.assign(elm.style, {
        width: '1px',
        height: '1px',
        position: 'absolute',
        left: '0',
        right: '0'
      });

      for (let j = 0; j < numClassesPerElement; j++) {
        const clazz = randomString();
        classes.push(clazz);
        elm.classList.add(clazz);
      }

      for (let j = 0; j < numAttributesPerElement; j++) {
        const attribute = randomAttribute();
        const attributeValue = randomString();
        attributes.push({ name: attribute, value: attributeValue });
        elm.setAttribute(attribute, attributeValue);
      }

      if (scopeToken) {
        if (useClasses) {
          elm.classList.add(scopeToken);
        } else {
          elm.setAttribute(scopeToken, '');
        }
      }

      // Chance of making the tree deeper or keeping it flat
      if (lastElm && randomCoin(0.75)) {
        lastElm.appendChild(elm);
      } else {
        renderRoot.appendChild(elm);
      }

      lastElm = elm;
    }

    return { component, tags, classes, attributes }
  }

  const generateStylesheetPromises = [];
  const newRoot = document.createElement('div');
  let lastComponent;

  for (let i = 0; i < numComponents; i++) {
    const scopeToken = scopeStyles && `scope-${++scopeId}`;
    const { component, tags, classes, attributes } = createComponent({ scopeToken });

    generateStylesheetPromises.push((async () => {
      const stylesheet = await generateRandomScopedCss({ classes, tags, attributes, scopeToken, useClasses, scopeMode, componentTag: component.tagName.toLowerCase() });

      if (useShadowDom) {
        return { shadowRoot: component.shadowRoot, stylesheet }
      } else {
        return stylesheet
      }
    })());

    // Chance of making the tree deeper or keeping it flat
    if (lastComponent && randomBool()) {
      (lastComponent.shadowRoot ?? lastComponent).appendChild(component);
    } else {
      newRoot.appendChild(component);
    }
    lastComponent = component;
  }

  function flushStyles(stylesheetsToProcess) {
    if (useShadowDom) {
      // We probably could have appended stylesheets to the shadow roots earlier,
      // but just in case browsers have some magic to process the stylesheet as early as possible,
      // do it at the same time we would be injecting global styles
      for (const { shadowRoot, stylesheet } of stylesheetsToProcess) {
        shadowRoot.appendChild(createStyleTag(stylesheet));
      }
    } else {
      if (oneBigStyle) {
        injectGlobalCss(stylesheetsToProcess.join('\n'));
      } else {
        for (const stylesheet of stylesheetsToProcess) {
          injectGlobalCss(stylesheet);
        }
      }
    }
  }

  // Flush everything to the DOM in one go so we can measure accurately
  const stylesheetsToProcess = await Promise.all(generateStylesheetPromises);
  flushStyles(stylesheetsToProcess);
  container.appendChild(newRoot);

  performance.mark('start');
  // requestPostAnimationFrame polyfill
  requestAnimationFrame(() => {
    addEventListener('message', () => {
      performance.measure('total', 'start');
      display.innerHTML += `${performance.getEntriesByType('measure').slice(-1)[0].duration}ms\n`;

      logChecksums();

    }, { once: true });
    postMessage('', '*');
  });
}

async function logChecksums() {
  // Make sure the HTML is the same every time
  console.log('html digest', await digestMessage(container.getInnerHTML ? container.getInnerHTML({ includeShadowRoots: true }) : container.innerHTML));
  console.log('style digest', await digestMessage($$('style').map(_ => _.textContent).join('\n')));
}

async function digestMessage(message) {
  const msgUint8 = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

const params = new URLSearchParams(location.search);

async function main() {
  if (params.get('auto') === 'true') {
    for (const input of $$('form input')) {
      const { id } = input;
      const val = params.get(id);
      if (val) {
        if (input.type === 'number') {
          input.value = parseInt(val, 10);
        } else if (input.type === 'checkbox' || input.type === 'radio') {
          input.checked = val === 'true';
        }
      }
    }
    // Avoid measuring the style/layout of the form elements
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
    await doRunTest();
  }
}

main().catch(err => {
  console.error(err);
});
//# sourceMappingURL=index.js.map
